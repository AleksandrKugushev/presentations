- Введение
    - TODO: шутка, история
    - Что такое функциональные тесты
        - Показать пирамиду тестирования
        - Сравнить функциональные, интеграционные и модульные тесты
            - Интеграционные тесты направлены на проверку интеграции
            - Модульные связаны с функциональностью модуля. Одной story может соответствовать множество модульных тестов
            - Функциональные тесты покрывают всю систему и проверяют именно конкретные stories. Нас интересуют именно бизнет требования, а значит мы можем поступиться тестированием некоторых интеграционных особенностей (забить)
        - Зачем они нужны
            - Проблема: нахрена это была добавлена эта строчка (дополнение к blame)
            - Покрытие legacy системы стоит начинать именно с функциональных, так как модульные будут сильно оторваны от бизнес требований а интеграционные слишком сложные
            - Лучшее вовлечение бизнес аналитиков и produc owner в разработку
    - А может отдать это Auto-QA? Вообще можно, но так мы получаем массу приемуществ:
        - Мы можем сначала написать высокоуровневые тесты. Я специально не говорю про BDD, но мы меня поняли ;-)
        - Уменьшается время разработки, так как нам реже нужно запускать все приложение. Запускаем только конкретные тесты
        - Автоматизаторы, как правило, строят сложную инфраструктуру, которая долго поднимается и сложно настраивается. Наша цель - **функциональные тесты, которые можно было бы запускать как модульные тесты.**

- Как создавать функциональные тесты
    - Prerequisites: мы будем говорить о WebApi. Тестирование шаблонизации на Razor is out of scope. Но там отличий не много (нужно просто парсер добавить)
    - TODO: попробовать приложение от community
    - Мы хотим дергать api локально так, как будто через curl, что бы вызывались все middlewares, отрабатывал routing и проч.
    - Для этого у нас есть WebApplicationFactory, которой можно скормить Startup.cs
        - Обратите внимание, что все что вы делаете в Program.cs тут не будет отражено
        - Для более сложных случаев нам стоит использовать наследника
        - В appSettings.json мы определяем deployment agnostic данные. Только при таком деплое его не будет видно. Решение - builder.UseContentRoot(".")
        - Что бы переопределить appSettings.Development.json, мы добавляем builder.ConfigureAppConfiguration(b => b.AddInMemoryCollection(FakeConfig));

- Как добавлять высокоуровневые заглушки

- Как сделать их понятными для не программистов

- Заключение
    - 
    - Что почитать
        - [Integration tests in ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-2.2)
        - 
        
