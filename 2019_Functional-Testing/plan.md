- Введение
    - TODO: шутка, история
    - Отказ от ответственности: я не буду рассказывать о каких то сверхестественных тулах, но вместе они работают очень эффективно и позваляют решать поставленную задачу
    - Что такое функциональные тесты
        - Показать пирамиду тестирования
        - Сравнить функциональные, интеграционные и модульные тесты
            - Интеграционные тесты направлены на проверку интеграции
            - Модульные связаны с функциональностью модуля. Одной story может соответствовать множество модульных тестов
            - Функциональные тесты покрывают всю систему и проверяют именно конкретные stories. Нас интересуют именно бизнет требования, а значит мы можем поступиться тестированием некоторых интеграционных особенностей (забить)
        - Зачем они нужны
            - Проблема: нахрена это была добавлена эта строчка (дополнение к blame)
            - Покрытие legacy системы стоит начинать именно с функциональных, так как модульные будут сильно оторваны от бизнес требований а интеграционные слишком сложные
            - Лучшее вовлечение бизнес аналитиков и produc owner в разработку
    - А может отдать это Auto-QA? Вообще можно, но так мы получаем массу приемуществ:
        - Мы можем сначала написать высокоуровневые тесты. Я специально не говорю про BDD, но мы меня поняли ;-)
        - Уменьшается время разработки, так как нам реже нужно запускать все приложение. Запускаем только конкретные тесты
        - Автоматизаторы, как правило, строят сложную инфраструктуру, которая долго поднимается и сложно настраивается. Наша цель - *функциональные тесты, которые можно было бы запускать как модульные тесты.*

- System under tests
    - В детстве мы все любили мультфильм X-Men. Какой у вас был любимый герой?
    - Как обсуждают дети своих любимых героев? Спорят кто - кого победит
    - В таких спорах всегда побеждал не тот, у кого были лучше аргументы, а у кого были сильнее друзья
    - Хотелось бы иметь такую систему, которая бы 100% помогала нам решать такие споры
    - Показать систему в которой будет:
        - appSettings.json - адрес автора, которому слать донат
        - appSettings.Development.json - postgresql connection string
        - authentification middleware (Google)
    - Мы будем говорить о WebApi. Тестирование шаблонизации на Razor is out of scope. Но там отличий не много (нужно просто парсер добавить)
    - Мы не будем рассматривать суперсложные кейсы. Цель доклада не убедить вас в необходимости написания функциональных тестов, а в том что бы рассмотреть технологии и понять как это делать эффективно.

- Как создавать функциональные тесты
    - **Тестируем метод, который принимает id двух мутантов и возвращает кто победит**
    - Мы хотим дергать api локально так, как будто через curl, что бы вызывались все middlewares, отрабатывал routing и проч.
    - Для этого у нас есть WebApplicationFactory, которой можно скормить Startup.cs
        - Обратите внимание, что все что вы делаете в Program.cs тут не будет отражено
        - Для более сложных случаев нам стоит использовать наследника
        - Что бы переопределить appSettings.Development.json, мы добавляем builder.ConfigureAppConfiguration(b => b.AddInMemoryCollection(FakeConfig));
    - Что делать с AddAuthentification middleware?
        - Пронаследуемся от Startup.cs и сделаем override определенного метода. Использовать Google OAuth
        - Но нам же нужен пользователь: добавляем тестовую схему аутентификации с захардкоженными клеймами 

- Как добавлять высокоуровневые заглушки
    - Добавляем заглушки для EntityFramework
        - **PUT мутанта по его ID (проставляя поле "кто сохранил") мутанта**
        - 2 варианта: In Memory и Sqlite
            - In memory не требует сохранения контекста
            - Sqlite предоставляет нормальную СУБД для работы
        - Выберем in memory
        - Нужно понимать, что в рамках ожного запуска база не меняется, бд иницииируется через OneTimeSetUp
        - Записываем данные и делаем Assert из EF
        - **GET живого мутанта (проверяем что он еще не умер)**
        - Записать в БД мутанта и сделать Assert
    - Добавляем заглушки для HttpClient и autorest
        - **Режим пафосного боя: победитель говорит крутую фразу в конце**
        - Используем https://quotes.rest
        - С помощью mockHttp подменяем простой get запрос
        - **Проверяем что гамбит говорит цитату в категории funny**
        - Используем With ...
        - P.S. Рассказать про WithAny
        - Для autorest - показать просто слайд
    - А что делать для всего остального
        - Docker: отсылка на доклад Горшколепа
        - Оставить как есть, если это 100% зависимость, например Consul или файловая система
        - Замокать, ведь для нас важна функциональная часть, а не интеграция

- Как сделать их понятными для не программистов
    - Зачем это делать
        - Business people смогут провалидировать то что вы пишете и найти ошибки еще до начала тестирования        
        - Им проще "продать" тесты: они видят что вы делаете
        - А еще они лучше вовлекаются в технические детали, например становится вполне реально показывать json product owner-у
        - Легкий вход для новых разработчиков, так как тесты становятся более читабельными
    - Язык Gerkhin (показать таблицы из wikipedia)
    - BDD фреймворки
        - Какие бывают: Specflow, BDDfy, XBehave
        - Мы рассмотрим XBehave так как он наиболее простой, но у него есть один серьездный недостаток - отутствие встроенного импорта отчетов
        - **Переделываем существующие тесты в XBehave**
        - Как сделать отчет в md
            - https://github.com/appccelerate/xBehaveMarkdownReport но это требует дополнительной настройки CI
            - Альтернатива: выгрузка из trx файла, показать powershell

- Заключение
    - 
    - Что почитать
        - [Integration tests in ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-2.2)
        - 
        
